ruby client generator:
  -- api/app/models/RubyClientGenerator.scala -> moduleName needs to take into account service.namespace

Breaking changes:
  - Change 404s to be explicit

update release notes

  - new features in api.json:

    - namespace: specifies the namespace for this service. Namespace
      is primarily used when other services import definitions from
      your service and in the code generators when defining things
      like package names. If not specified, we will automatically
      generate a namespace based on [organization
      namespace].[formatted service name].[major version number]. Note
      that by default apidoc includes the major version number in the
      package name which allows service authors and clients to
      interact with multiple versions of the service where changes
      have been made in a non backwards compatible way.

      organization level package name has been renamed to namespace
      and is now required.

    - base url is now optional avoiding need to guess the url during
      initial development (before service is deployed)

    - imports

  - introduction of service.json

  - package name changes (formatting injects dots now)
     - "error" is renamed to "errors" to match pluralization of models and enums

  - document addition of major version number to package names

  - FailedRequest class moved to error package

  - FailedRequest changed to have a simpler signature:
     - Removed full response
     - Expose HTTP Status code and a message
     - makes the class serializable as well
     - moved to "errors" package

  - reorder params so form is last
      override def postByOrgKey(domain: com.gilt.apidoc.models.Domain,
        orgKey: String
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[com.gilt.apidoc.models.Domain] = {

      is now

      override def postByOrgKey(
        orgKey: String,
        domain: com.gilt.apidoc.models.Domain
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[com.gilt.apidoc.models.Domain] = {

      parameters in the function list are ordered by:
        all required query / form parameters first
        the body, if present
        remaining parameters

  - scala Client API:

      From: class Client(apiUrl: String, apiToken: scala.Option[String] = None)
      To: class Client(apiUrl: String, auth: scala.Option[com.gilt.apidoc.v0.Authorization] = None)

    Allows support of other auth methods rather than just the initial
    token use case we had. In order to use a token, create an instace
    of basic authorization with:

       com.gilt.apidoc.v0.Authorization("token")
    
apidoc-generator:
  ==> TODO: union type

api + spec:
  - introduce service_form distinct from service. Replaces JsObject in
    version.service

Generators:
  - Cache the generators

users:
  - add nickname that users can modify, and display that nickname throughout the API

UX:

  - On adding watch, check subscription and offer the user to enable
    the relevant subscriptions if not subscribed

  - On service visibility - if service is public and org is NOT, add
    note that the service will not be visible until the org is made
    public.

Org level setting to enable semver versioning (default on)
  - prevent backwards incompatible changes once at major version 1

Email user when their membership request has been processed

Implement subscriptions.finaAll authorization filter

Add user_form to api.json and remove db.UserDao.UserForm

Implement backwards compatibility layer - each new version of a
service should be automatically validated against the latest version
with the same major version number. Consider if we require semver
versioning or not.

Automate end to tests of generated clients. Currently client libraries
are tested offline and manually. Need to think through how testing
will work across mulitple platforms.
  
api.json: Support authentication, documentation
  
Swagger 2.0 was released in September 2014. Explore if swagger 2.0 can become the input spec for apidoc.
