@import core.generator.Target

@doc.main("Code Generation") {

  <p>

    At a high level, Apidoc is designed and built to work 100% on its
    own with zero dependencies. That is - if you like the quality of
    the documentation, you can simply use Apidoc for hosting your
    documentation.

  </p>

  <p>

    Over time, we've seen interest in exploring ways of taking the
    schema design provided through api.json and linking it further
    into the development process. One pragmatic way to do this is to
    use code generation in various forms. We are generally very
    cautious about code generation and in each area we explore the
    opportunities and tradeoffs for code generation. In some cases, we
    have found the code generation to be particularly useful in terms
    of ensuring that the services we create actually conform to the
    specification or in consuming services that are described by
    api.json.

  </p>

  <p>

    Our general philosophy on code generation is to focus generally
    on these benefits:

    <ol>

      <li> Scaffolding: One time code generation to speed up initial
      development. Also a huge benefit for learning how to use
      services.</li>

      <li> Quality: Can we help ensure services meet their
      specifications? Can we improve end point testing by generating
      tests based on the specification?</li>

      <li> Reduction of dependencies: If we code generate, can we
      leverage the native libraries already present in a framework
      rather than introduce new dependencies?</li>

    </ol>

  </p>

  <table class="table table-hover table-condensed">
    <tmain>
       <tr>
         <th>Status</th>
         <th>Platform</th>
         <th>Notes</th>
       </tr>
    </tmain>

    <tbody>

      @core.generator.Target.All.map { target =>
        <tr>
          <td>@target.status</td>
          <td>@target.key</td>
          <td>@Html(target.description)</td>
        </tr>
      }
    </tbody>
  </table>

}
